# Effect Descriptions Design Document

**Status:** Design Phase
**Created:** 2025-01-25
**Last Updated:** 2025-01-25
**Related Files:**
- [character_components.py](../src/characters/character_components.py) - Effect model
- [state_commands_optimized.py](../src/models/state_commands_optimized.py) - EffectCommand
- [state_command_executor.py](../src/memory/state_command_executor.py) - Effect execution

---

## Problem Statement

After simplifying the effect system to use text-based descriptions (instead of structured fields like `flat_modifiers`, `dice_modifiers`, etc.), we need to design how effect descriptions are sourced and attached to character sheets.

### Key Questions:
1. Should agents generate descriptions themselves, or retrieve from a database?
2. If database, how do we handle exact matches vs fuzzy matches?
3. How do we handle homebrew/custom effects not in the database?
4. What caching strategy should we use to avoid repeated lookups?
5. Where in the agent pipeline should description lookup/generation happen?

---

## Current Architecture Context

### Effect System Overview

**Effect Model** ([character_components.py:21-76](../src/characters/character_components.py)):
```python
class Effect(BaseModel):
    name: str
    effect_type: str  # "buff", "debuff", "condition", "spell"
    duration_type: DurationType
    duration_remaining: int
    source: str
    description: str  # Full text description (REQUIRED)
    summary: Optional[str] = None  # Brief summary for compact display
```

**EffectCommand** ([state_commands_optimized.py:70-141](../src/models/state_commands_optimized.py)):
```python
class EffectCommand(BaseModel):
    type: Literal["effect"] = "effect"
    character_id: str
    action: Literal["add", "remove"]
    effect_name: str

    # Only for action="add"
    duration_type: Optional[DurationType]
    duration: Optional[int]
    description: Optional[str]  # Agents must provide this
    summary: Optional[str]
    effect_type: Optional[str] = "buff"
```

### Agent Pipeline Flow

```
User Input
  ↓
DungeonMasterAgent (generates narrative)
  ↓
StateExtractionOrchestrator
  ├─► EventDetector
  ├─► CombatStateExtractor (parallel)
  └─► ResourceExtractor (parallel)
  ↓
StateCommandExecutor (applies EffectCommands to Characters)
```

**Current Behavior:** State extraction agents must provide `description` when creating `EffectCommand`. There's no centralized lookup or caching.

### Vector Database Status

**Current Status:** Vector database infrastructure exists but is **unused**.

- **Files:** `src/db/vector_service.py`, `src/db/combat_rules.json`
- **Vector DB:** Qdrant (considering switch to LanceDB)
- **Embedding Model:** `gemini-embedding-001` (768 dimensions)
- **Current Content:** D&D 5e combat rules (442 lines), NOT effect descriptions

**DM Agent:** Does NOT retrieve rules from vector DB during response generation. All rule knowledge comes from model pretraining + system prompt.

---

## Design Options

### Option 1: Agent-Generated Descriptions (Current Approach)

State extraction agents write descriptions inline when creating EffectCommands.

**Flow:**
```python
# In CombatStateExtractor
effect_command = EffectCommand(
    effect_name="Bless",
    description="Grants +1d4 to attack rolls and saving throws",  # Generated by agent
    summary="+1d4 attacks/saves"
)
```

**Pros:**
- ✅ Already working
- ✅ Context-aware (agent saw the narrative)
- ✅ Handles custom/homebrew effects naturally
- ✅ No additional infrastructure needed

**Cons:**
- ❌ Inconsistent descriptions across sessions
- ❌ Agents must write descriptions for common spells repeatedly (token waste)
- ❌ May miss mechanical details
- ❌ Increases extraction latency and cost

---

### Option 2: Database Lookup Only (No Fallback)

Create a database of standard D&D effects and require exact matches.

**Flow:**
```python
# Effect agent creates command with name only
effect_command = EffectCommand(
    effect_name="Bless",
    description=None  # Not provided
)

# Enricher looks up in database
description = effect_db.get_exact("Bless")
if description:
    effect_command.description = description
else:
    raise ValueError("Unknown effect")
```

**Pros:**
- ✅ Consistent descriptions
- ✅ Fast lookups
- ✅ Single source of truth

**Cons:**
- ❌ Can't handle custom effects
- ❌ Can't handle typos or variations ("bless" vs "Bless" vs "blessing")
- ❌ Brittle - fails on any unknown effect

---

### Option 3: Vector Search Only (Semantic Matching)

Use vector database for all effect lookups.

**Flow:**
```python
# Semantic search
results = vector_db.search("flameball", top_k=1)
if results[0].score > 0.85:
    description = results[0].description
else:
    # Generate with LLM
    description = llm_generate(effect_name, context)
```

**How Vector Search Works:**
- Query "flameball" → embedding vector
- Compare against all database vectors (each from `effect_name + "\n\n" + description`)
- Returns cosine similarity scores (0-1)
- "flameball" would match "Fireball" with score ~0.92 (very high)

**Pros:**
- ✅ Handles typos and variations
- ✅ Semantic understanding ("healing word" ≈ "cure wounds")
- ✅ Single unified lookup mechanism

**Cons:**
- ❌ Slower than exact match (network call + vector computation)
- ❌ Ambiguous short queries ("fire" could match many spells)
- ❌ Requires vector DB setup and maintenance
- ❌ Still needs LLM fallback for custom effects

---

### Option 4: Two-Tier Hybrid (Exact Match → Vector Search) **[RECOMMENDED]**

Combine exact matching for common cases with vector search for edge cases.

**Flow:**
```python
def get_effect_description(effect_name: str, context: str = None):
    """Three-tier lookup: exact → vector → LLM"""

    # Tier 1: Exact match (fast - O(1), in-memory)
    normalized = effect_name.lower().strip()
    if normalized in STANDARD_EFFECTS:
        return STANDARD_EFFECTS[normalized]

    # Tier 2: Vector search (medium - semantic matching)
    if vector_db:
        results = vector_db.search(effect_name, threshold=0.85)
        if results and results[0].score > 0.85:
            return results[0]

    # Tier 3: LLM generation (slow - handles anything)
    return llm_generate_description(effect_name, context)
```

**Pros:**
- ✅ Fast for 95% of cases (standard spells)
- ✅ Handles variations via vector search
- ✅ Handles custom effects via LLM fallback
- ✅ No network call for common cases
- ✅ Graceful degradation (works without vector DB)

**Cons:**
- ❌ More complex implementation
- ❌ Requires maintaining standard effects dict

---

### Option 5: Post-Extraction Enrichment Agent

Add a dedicated agent that enriches EffectCommands after state extraction.

**Flow:**
```
StateExtractor creates EffectCommand (name + duration only)
  ↓
EffectDescriptionEnricher agent:
  - Queries vector DB for known effects
  - Generates descriptions for unknowns
  - Enriches commands with description + summary
  ↓
StateCommandExecutor applies enriched commands
```

**Pros:**
- ✅ Separation of concerns (extraction vs enrichment)
- ✅ Can use hybrid lookup approach (exact + vector + LLM)
- ✅ Fits naturally into existing pipeline
- ✅ Can cache descriptions in session context
- ✅ Parallelizable with other post-extraction tasks

**Cons:**
- ❌ Additional agent in pipeline (slight latency)
- ❌ More complex orchestration
- ❌ Enricher doesn't have full narrative context (only sees commands)

---

## Recommended Approach: Hybrid Storage + Optional Enrichment

### Architecture

**Phase 1: Hybrid Storage (Implement First)**

```python
# src/db/standard_effects.py
STANDARD_EFFECTS = {
    "bless": {
        "name": "Bless",
        "description": "Whenever you make an attack roll or a saving throw before the spell ends, you can roll a d4 and add the number rolled to the attack roll or saving throw.",
        "summary": "+1d4 to attack rolls and saving throws",
        "duration_type": "concentration",
        "default_duration": 10,
        "effect_type": "buff",
        "tags": ["buff", "cleric", "1st-level", "concentration"]
    },
    "haste": {
        "name": "Haste",
        "description": "Target gains +2 AC, advantage on Dexterity saving throws, doubled speed, and an additional action each turn (Attack, Dash, Disengage, Hide, or Use an Object only).",
        "summary": "+2 AC, adv Dex saves, 2x speed, extra action",
        "duration_type": "concentration",
        "default_duration": 10,
        "effect_type": "buff",
        "tags": ["buff", "transmutation", "3rd-level", "haste", "concentration"]
    },
    "poisoned": {
        "name": "Poisoned",
        "description": "A poisoned creature has disadvantage on attack rolls and ability checks.",
        "summary": "Disadv on attacks & checks",
        "effect_type": "condition",
        "tags": ["condition", "debuff", "poisoned"]
    }
    # ... ~200 more standard D&D effects
}
```

**Phase 2: Lookup Service**

```python
# src/db/effect_lookup_service.py
class EffectLookupService:
    """Hybrid lookup: exact match → vector search → LLM generation"""

    def __init__(self, vector_db=None, llm_client=None):
        self.standard_effects = STANDARD_EFFECTS
        self.vector_db = vector_db  # Optional
        self.llm_client = llm_client  # Optional
        self.session_cache = {}  # Cache custom effects within session

    def lookup(self, effect_name: str, context: str = None, session_id: str = None):
        """Three-tier lookup with session caching"""

        # Check session cache first (for repeated custom effects)
        cache_key = f"{session_id}:{effect_name.lower()}"
        if session_id and cache_key in self.session_cache:
            return {
                "source": "session_cache",
                "confidence": 1.0,
                **self.session_cache[cache_key]
            }

        # Tier 1: Exact match (case-insensitive)
        normalized = effect_name.lower().strip()
        if normalized in self.standard_effects:
            return {
                "source": "exact_match",
                "confidence": 1.0,
                **self.standard_effects[normalized]
            }

        # Tier 2: Vector search (if available)
        if self.vector_db:
            results = self.vector_db.search(effect_name, top_k=1)
            if results and results[0]["score"] >= 0.85:
                return {
                    "source": "vector_search",
                    "confidence": results[0]["score"],
                    **results[0]
                }

        # Tier 3: LLM generation (if available and context provided)
        if self.llm_client and context:
            result = self._generate_description(effect_name, context)

            # Cache in session
            if session_id:
                self.session_cache[cache_key] = result

            return {
                "source": "llm_generated",
                "confidence": 0.8,
                **result
            }

        # Tier 4: Not found
        return {
            "source": "not_found",
            "confidence": 0.0,
            "name": effect_name,
            "description": f"Effect: {effect_name}",
            "summary": effect_name
        }

    def _generate_description(self, effect_name: str, context: str):
        """Use LLM to generate effect description from context"""
        prompt = f"""Based on this D&D narrative context, generate a concise effect description:

Context: {context}

Effect Name: {effect_name}

Provide:
1. description: A one-sentence description of what the effect does mechanically
2. summary: A 3-5 word summary for compact display

Format as JSON."""

        # Call LLM (Gemini 1.5 Flash for speed/cost)
        response = self.llm_client.generate(prompt)
        return response  # {description: "...", summary: "..."}
```

**Phase 3: Integration into State Extraction**

```python
# In CombatStateExtractor/ResourceExtractor
from src.db.effect_lookup_service import EffectLookupService

class CombatStateExtractor:
    def __init__(self, effect_lookup: EffectLookupService = None):
        self.effect_lookup = effect_lookup or EffectLookupService()

    def extract(self, context: str):
        # ... extract effect_name, duration, etc.

        # Look up description
        effect_info = self.effect_lookup.lookup(
            effect_name="Bless",
            context=context,
            session_id=self.session_id
        )

        # Create command with enriched info
        return EffectCommand(
            effect_name=effect_info["name"],
            description=effect_info["description"],
            summary=effect_info["summary"],
            duration_type=effect_info.get("duration_type", "rounds"),
            duration=effect_info.get("default_duration", 1)
        )
```

---

## Implementation Plan

### Phase 1: Foundation (Week 1)
- [ ] Create `src/db/standard_effects.py` with ~50 common spells/conditions
- [ ] Create `src/db/effect_lookup_service.py` with exact match only
- [ ] Update state extraction agents to use lookup service
- [ ] Add session caching for custom effects
- [ ] Test with standard spells (Bless, Haste, Hunter's Mark, etc.)

### Phase 2: Vector Search (Week 2-3) - OPTIONAL
- [ ] Evaluate LanceDB vs Qdrant for effect descriptions
- [ ] Create effect descriptions collection (~200 entries)
- [ ] Implement vector search fallback in lookup service
- [ ] Test fuzzy matching ("flameball" → "Fireball", "bless spell" → "Bless")
- [ ] Benchmark performance (exact vs vector)

### Phase 3: LLM Fallback (Week 3-4) - OPTIONAL
- [ ] Implement `_generate_description()` with Gemini 1.5 Flash
- [ ] Add context-aware description generation
- [ ] Test with homebrew/custom effects
- [ ] Measure token costs and latency

### Phase 4: Optimization (Week 4+)
- [ ] Add description quality validation
- [ ] Implement description versioning (for updates)
- [ ] Add admin UI for managing standard effects
- [ ] Export session cache for repeated custom effects

---

## Data Structure Design

### Standard Effects JSON Structure

```json
{
  "effects": {
    "bless": {
      "name": "Bless",
      "description": "Whenever you make an attack roll or a saving throw before the spell ends, you can roll a d4 and add the number rolled to the attack roll or saving throw.",
      "summary": "+1d4 to attack rolls and saving throws",
      "duration_type": "concentration",
      "default_duration": 10,
      "effect_type": "buff",
      "spell_level": 1,
      "classes": ["cleric", "paladin"],
      "tags": ["buff", "support", "concentration"],
      "source": "PHB p.219"
    }
  }
}
```

### Vector DB Entry Structure (If Implemented)

```json
{
  "id": "bless_spell",
  "effect_name": "Bless",
  "text": "Bless\n\nWhenever you make an attack roll or a saving throw before the spell ends, you can roll a d4 and add the number rolled to the attack roll or saving throw.",
  "payload": {
    "name": "Bless",
    "name_normalized": "bless",
    "description": "Whenever you make an attack roll...",
    "summary": "+1d4 to attack rolls and saving throws",
    "duration_type": "concentration",
    "default_duration": 10,
    "tags": ["buff", "cleric", "1st-level"]
  },
  "embedding": [0.023, -0.145, 0.891, ...]
}
```

**What gets embedded:** `effect_name + "\n\n" + description` (concatenated)

---

## Performance Considerations

### Lookup Performance Comparison

| Method | Latency | Cost | Accuracy | Use Case |
|--------|---------|------|----------|----------|
| **In-memory dict** | <1ms | Free | 100% (exact) | Standard spells |
| **Vector search** | 50-100ms | ~$0.0001/query | 95% (fuzzy) | Variants/typos |
| **LLM generation** | 500-2000ms | ~$0.001-0.01/gen | 80-90% | Custom effects |

### Token Cost Analysis

**Current (Agent-Generated):**
- Every effect extraction: ~100 tokens × $0.15/1M = $0.000015/effect
- 1000 effects/day = $0.015/day = $5.48/year

**Proposed (Hybrid Lookup):**
- 95% exact match: Free
- 4% vector search: $0.0001/query × 40/day = $0.004/day = $1.46/year
- 1% LLM generation: $0.005/gen × 10/day = $0.05/day = $18.25/year
- **Total: ~$20/year** (64% savings)

### Session Caching Benefits

If a custom effect appears 10 times in a session:
- Without cache: 10 × LLM generation = 10 × $0.005 = $0.05
- With cache: 1 × LLM generation + 9 × cache hit = $0.005
- **90% cost reduction for repeated custom effects**

---

## Open Questions

1. **Vector DB Selection:**
   - Should we use LanceDB (local, simpler) or Qdrant (scalable, cloud)?
   - Do we need vector search at all, or is exact match + LLM fallback sufficient?

2. **Standard Effects Scope:**
   - How many effects should be in the standard dictionary? (50? 200? 500?)
   - Should we include all PHB spells, or just commonly used ones?
   - Should we include class features (Rage, Sneak Attack, etc.)?

3. **Description Quality:**
   - Should we validate generated descriptions for completeness?
   - How do we handle effect description updates/corrections?
   - Should we allow users to override descriptions?

4. **Integration Point:**
   - Should description lookup happen IN state extraction agents, or AFTER in an enrichment step?
   - Should we make description optional in EffectCommand validation?

5. **Caching Strategy:**
   - Should session cache persist across sessions for a campaign?
   - Should we export/import cached custom effects?
   - How do we handle cache invalidation?

---

## Next Steps

1. **Complete testing of simplified effect system** (current priority)
2. **Create `standard_effects.py`** with ~50 common D&D effects
3. **Implement `EffectLookupService`** with exact match only
4. **Integrate into state extraction agents**
5. **Decide on vector DB approach** (defer until Phase 2)

---

## References

- [Effect Model](../src/characters/character_components.py) - Text-based effect implementation
- [EffectCommand](../src/models/state_commands_optimized.py) - Command schema
- [State Extraction](../src/agents/hp_agent.py) - Example extraction agent
- [Vector Service](../src/db/vector_service.py) - Current (unused) vector DB implementation
- [Combat Rules](../src/db/combat_rules.json) - Example of structured rule data

---

**Document Status:** Draft - Ready for implementation after testing completion
